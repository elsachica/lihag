stages:
  - build
  - test
  - staging
  - deploy

# Property Service (ACTIVE - ready for deployment)
# build_property:
#   stage: build
#   image:
#     name: gcr.io/kaniko-project/executor:v1.9.0-debug
#     entrypoint: [""]
#   script:
#     - echo "{\"auths\":{\"$CI_REGISTRY\":{\"auth\":\"$(printf '%s' "gitlab-ci-token:${CI_JOB_TOKEN}" | base64)\"}}}" > /kaniko/.docker/config.json
#     - /kaniko/executor --context "${CI_PROJECT_DIR}/services/property" --dockerfile "${CI_PROJECT_DIR}/services/property/Dockerfile" --destination "gitlab.lnu.se:5050/2dv013/student/team-2025-07-4chics/lihag-system/property:${CI_COMMIT_REF_SLUG}"
#     - echo "✓ Successfully built and pushed property:${CI_COMMIT_REF_SLUG}"

# test_property:
#   stage: test
#   image: node:20
#   script:
#     - cd services/property
#     - npm ci
#     - npm run lint || echo "No linter configured"
#     - npm test || echo "No tests yet"

# Auth Service (commented out - not ready yet)
# build_auth:
#   stage: build
#   image:
#     name: gcr.io/kaniko-project/executor:v1.9.0-debug
#     entrypoint: [""]
#   script:
#     - echo "{\"auths\":{\"$CI_REGISTRY\":{\"auth\":\"$(printf '%s' "gitlab-ci-token:${CI_JOB_TOKEN}" | base64)\"}}}" > /kaniko/.docker/config.json
#     - /kaniko/executor --context "${CI_PROJECT_DIR}/services/auth" --dockerfile "${CI_PROJECT_DIR}/services/auth/Dockerfile" --destination "gitlab.lnu.se:5050/2dv013/student/team-2025-07-4chics/lihag-system/auth:${CI_COMMIT_REF_SLUG}"
#     - echo "✓ Successfully built and pushed auth:${CI_COMMIT_REF_SLUG}"

# test_auth:
#   stage: test
#   image: node:20
#   script:
#     - cd services/auth
#     - npm ci
#     - npm run lint || echo "No linter configured"
#     - npm test || echo "No tests yet"

# Maintenance Service (commented out - not ready yet)
# build_maintenance:
#   stage: build
#   image:
#     name: gcr.io/kaniko-project/executor:v1.9.0-debug
#     entrypoint: [""]
#   script:
#     - echo "{\"auths\":{\"$CI_REGISTRY\":{\"auth\":\"$(printf '%s' "gitlab-ci-token:${CI_JOB_TOKEN}" | base64)\"}}}" > /kaniko/.docker/config.json
#     - /kaniko/executor --context "${CI_PROJECT_DIR}/services/maintenance" --dockerfile "${CI_PROJECT_DIR}/services/maintenance/Dockerfile" --destination "gitlab.lnu.se:5050/2dv013/student/team-2025-07-4chics/lihag-system/maintenance:${CI_COMMIT_REF_SLUG}"
#     - echo "✓ Successfully built and pushed maintenance:${CI_COMMIT_REF_SLUG}"

# test_maintenance:
#   stage: test
#   image: node:20
#   script:
#     - cd services/maintenance
#     - npm ci
#     - npm run lint || echo "No linter configured"
#     - npm test || echo "No tests yet"

# Frontend (commented out - not ready yet)
build_frontend:
  stage: build
  image:
    name: gcr.io/kaniko-project/executor:v1.9.0-debug
    entrypoint: [""]
  script:
    - |
      echo "{\"auths\":{\"$CI_REGISTRY\":{\"auth\":\"$(printf '%s' "gitlab-ci-token:${CI_JOB_TOKEN}" | base64)\"}}}" > /kaniko/.docker/config.json

      IMAGE_TAG="${CI_COMMIT_TAG:-latest}"
      IMAGE="${CI_REGISTRY_IMAGE}/frontend:${IMAGE_TAG}"

      echo "IMAGE_TAG=${IMAGE_TAG}" > build.env
      echo "IMAGE=${IMAGE}" >> build.env


      /kaniko/executor --context "${CI_PROJECT_DIR}/frontend" --dockerfile "${CI_PROJECT_DIR}/frontend/Dockerfile" --destination "${IMAGE}" --snapshotMode=redo --reproducible

  when: manual

# test_frontend:
#   stage: test
#   image: node:20
#   script:
#     - cd frontend
#     - npm ci
#     - npm run lint || echo "No linter configured"
#     - npm test || echo "No tests yet"

# Kubernetes Deployment
deploy_staging:
  stage: staging
  image:
    name: gcr.io/k8s-skaffold/skaffold:v2.8.0
    entrypoint: ['']
  variables:
    KUBECONFIG_PATH: "/root/.kube/config"
    NAMESPACE: "default"
  before_script:
    - mkdir -p "$(dirname "${KUBECONFIG_PATH}")"
    - 'test -f "${KUBE_CONFIG_STAGING}" && cp "${KUBE_CONFIG_STAGING}" "${KUBECONFIG_PATH}" || (printf "%s" "${KUBE_CONFIG_STAGING}" | base64 --decode > "${KUBECONFIG_PATH}" 2>/dev/null || printf "%s" "${KUBE_CONFIG_STAGING}" | base64 -D > "${KUBECONFIG_PATH}" 2>/dev/null || (echo "KUBE_CONFIG_STAGING is not a file path and not valid base64" >&2; exit 1))'
    - chmod 600 "${KUBECONFIG_PATH}"
    - kubectl version --client
  script:
    - |
      echo "Creating ImagePullSecret for GitLab Container Registry..."
      # ensure IMAGE is defined in this job
      IMAGE_TAG="${CI_COMMIT_TAG:-latest}"
      IMAGE="${CI_REGISTRY_IMAGE}/frontend:${IMAGE_TAG}"
      echo "IMAGE=${IMAGE}"
      # recreate secret (use --dry-run to avoid accidental interactive errors)
      kubectl delete secret regcred -n "${NAMESPACE}" --ignore-not-found || true
      kubectl create secret docker-registry regcred \
        --docker-server=gitlab.lnu.se:5050 \
        --docker-username="${CI_REGISTRY_USER}" \
        --docker-password="${CI_REGISTRY_PASSWORD}" \
        --docker-email="${GITLAB_USER_EMAIL:-you@example.com}" \
        -n "${NAMESPACE}" --dry-run=client -o yaml | kubectl apply -f -
      # deploy with skaffold (pass image built in pipeline)
      skaffold deploy --profile production --images "${IMAGE}"
      echo "Waiting for deployments to rollout..."
      kubectl get deployments -n "${NAMESPACE}" || true
      kubectl get pods -n "${NAMESPACE}" -o wide || true


    - echo "✓ Deployment complete!"

  only:
    - main
    - master
    - deploy
  when: manual
  environment:
    name: staging

deploy_production:
  stage: deploy
  image:
    name: gcr.io/k8s-skaffold/skaffold:v2.8.0
    entrypoint: ['']
  variables:
    KUBECONFIG_PATH: "/root/.kube/config"
    NAMESPACE: "default"
  before_script:
    - mkdir -p "$(dirname "${KUBECONFIG_PATH}")"
    - 'test -f "${KUBE_CONFIG_PRODUCTION}" && cp "${KUBE_CONFIG_PRODUCTION}" "${KUBECONFIG_PATH}" || (printf "%s" "${KUBE_CONFIG_PRODUCTION}" | base64 --decode > "${KUBECONFIG_PATH}" 2>/dev/null || printf "%s" "${KUBE_CONFIG_PRODUCTION}" | base64 -D > "${KUBECONFIG_PATH}" 2>/dev/null || (echo "KUBE_CONFIG_PRODUCTION is not a file path and not valid base64" >&2; exit 1))'
    - chmod 600 "${KUBECONFIG_PATH}"
    - kubectl version --client
  script:
    - |
      echo "Creating ImagePullSecret for GitLab Container Registry..."
      # ensure IMAGE is defined in this job
      IMAGE_TAG="${CI_COMMIT_TAG:-latest}"
      IMAGE="${CI_REGISTRY_IMAGE}/frontend:${IMAGE_TAG}"
      echo "IMAGE=${IMAGE}"
      # recreate secret (use --dry-run to avoid accidental interactive errors)
      kubectl delete secret regcred -n "${NAMESPACE}" --ignore-not-found || true
      kubectl create secret docker-registry regcred \
        --docker-server=gitlab.lnu.se:5050 \
        --docker-username="${CI_REGISTRY_USER}" \
        --docker-password="${CI_REGISTRY_PASSWORD}" \
        --docker-email="${GITLAB_USER_EMAIL:-you@example.com}" \
        -n "${NAMESPACE}" --dry-run=client -o yaml | kubectl apply -f -
      # deploy with skaffold (pass image built in pipeline)
      skaffold deploy --profile production --images "${IMAGE}"
      echo "Waiting for deployments to rollout..."
      kubectl get deployments -n "${NAMESPACE}" || true
      kubectl get pods -n "${NAMESPACE}" -o wide || true


    - echo "✓ Deployment complete!"

  only:
    - main
    - master
    - deploy
  when: manual
  environment:
    name: production